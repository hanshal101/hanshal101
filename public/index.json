[{"content":"Motivation In this blog series, we will deep dive into the fascinating world of eBPF (Extended Berkley Packet Filter) and its internals. Along the way, we will explore core BPF (Berkley Packet Filter) internals that are essential to understanding how eBPF operates under the hood. This journey will also include networking concepts, operating system principles, and computer architecture, all of which play a crucial role in making eBPF effective and powerful. Who should read this?: Everyone who\u0026rsquo;s curious about eBPF and Linux Kernel.\nWhat is eBPF? eBPF is a revolutionary kernel technology that allows developers to write custom code that can be loaded into the kernel dynamically, changing the way the kernel behaves. This enables a new generation of highly performant networking, observability, and security tools. And as you\u0026rsquo;ll see, if you want to instrument an app with these eBPF-based tools, you don\u0026rsquo;t need to modify or reconfigure the app in any way, thanks to eBPF\u0026rsquo;s vantage point within the kernel. Just a few of the things you can do with eBPF include:\nPerformance tracing of pretty much any aspect of a system High-performance networking, with built-in visibility Detecting and (optionally) preventing malicious activity History of eBPF Previously our OS was the center for all observability, networking and security functionality due to Kernel\u0026rsquo;s ability to oversee and control entire system. However, evolving these functionalities within the kernel was challenging due to its critical role in maintaining stability and security. This limitation led to slower innovation compared to functionalities developed outside of the operating system. The introduction of eBPF (Extended Berkeley Packet Filter) in 2014 revolutionized this landscape by allowing developers to run sandboxed programs directly within the Linux kernel without modifying its source code or loading additional modules.\nThe Linux Kernel The Linux kernel is the software layer between your applications and the hardware they\u0026rsquo;re running on. Applications run in an unprivileged layer called user space, which can\u0026rsquo;t access hardware directly. Instead, an application makes requests using the system call (syscall) interface to request the kernel to act on its behalf. That hardware access can involve reading and writing to files, sending or receiving network traffic, or even just accessing memory. The kernel is also responsible for coordinating concurrent processes, enabling many applications to run at once.\nA diagram of the Linux Kernel\nHow does eBPF programs run? In a higher level abstraction\neBPF programs can be writtern in languages like C/C++, Go, Rust, Python etc. Developers write eBPF programs primarily in restricted C or other supported languages. These programs are compiled into intermediary bytecode using tools like LLVM or clang. Then the bytecode is loaded into the Linux Kernel via tools like bpftool or through bpf() syscalls. After the program is loaded it goes through a verification process to make sure it is safe to run in the kernel. The verifier will check for potential issues like infinite loops, uninitialized variables, out-of-bound memory access, etc. If verified successfully, the bytecode is converted into native machine code by a JIT (Just-In-Time) compiler(We will discuss about this in later upcoming blogs) for efficient execution. The program then gets attached to specific hookpoints within the kernel. Example: syscalls, network events, Any event occuring at those hook points where the eBPF program is attached, it executes automatically. We can also make the eBPF program to interact with the user-space of the system. This is done for better visibility of the traces. At last once the task is completed or when no longer needed, eBPF programs can be unloaded from the kernel using system calls again.\nA diagram of the eBPF process\nBasic Terminologies in eBPF Maps Remember we discussed about how eBPF program can interact with the user-space? Well MAPS help us to do so. eBPF maps play a crucial role in facilitating data sharing and state management for eBPF programs. These maps enable the storage and retrieval of data using a variety of data structures, allowing eBPF programs to access them directly. Additionally, applications running in user space can also interact with these maps through system calls, providing a seamless way to exchange information between kernel and user space environments. Hash-tables, arrays, Ring-Buffer, LRU (Least Recently Used) are some supported map types. We will discuss in detail about different type of MAPS in upcoming blogs.\nHelper Calls eBPF programs are restricted from calling arbitrary kernel functions to maintain compatibility across different kernel versions. This limitation prevents eBPF programs from becoming tightly coupled with specific kernel releases, which would complicate their portability. Instead, eBPF programs can utilize a set of predefined and stable helper functions provided by the kernel. These helper functions offer a well-defined API that allows eBPF programs to perform various tasks without directly accessing the broader kernel functionality. Few helper calls include:\nGenerate random numbers Get current time \u0026amp; date eBPF map access Get process/cgroup context Manipulate network packets and forwarding logic Tail Calls Tail calls in eBPF allow developers to execute another eBPF program and replace the current execution context, somewhat analogous to how the execve() system call works for regular processes.\nFunction Calls Function calls in eBPF allow developers to define and invoke functions within an eBPF program, enhancing code reusability and modularity.\nWhy eBPF? eBPF is a versatile technology that offers several compelling reasons for its adoption across various domains, including security, observability, and networking\nSecurity eBPF provides fine-grained control over system calls and network activities, allowing for real-time threat detection and mitigation without modifying kernel source code. Its sandboxed environment ensures stability by preventing crashes or security breaches.\nObservability It enables non-invasive monitoring of system events with minimal performance impact. This allows for real-time tracing and customizable monitoring solutions tailored to specific use cases\nPerformance By executing directly within the kernel via JIT compilation, eBPF reduces latency and enhances throughput compared to traditional user-space applications. It also minimizes resource usage due to its lightweight nature.\nWhere is eBPF currently used? eBPF is currently used in a wide range of applications across various domains, including networking, security, and observability. In networking, eBPF is utilized for tasks such as traffic control, creating network policies, and connect-time load balancing in environments like Kubernetes. For security, it is employed for real-time threat detection by monitoring system calls and network activities to identify potential vulnerabilities. Additionally, eBPF enhances observability by providing granular insights into system metrics like CPU utilization and disk I/O operations. It also plays a crucial role in application performance monitoring by tracing micro-level events to optimize application performance. Tools like Cilium leverage eBPF for secure network connectivity and monitoring capabilities in cloud-native environments. Overall, its versatility makes it an essential tool across multiple industries.\n","permalink":"http://localhost:1313/blog/ebpf/introduction-to-ebpf/","summary":"Motivation In this blog series, we will deep dive into the fascinating world of eBPF (Extended Berkley Packet Filter) and its internals. Along the way, we will explore core BPF (Berkley Packet Filter) internals that are essential to understanding how eBPF operates under the hood. This journey will also include networking concepts, operating system principles, and computer architecture, all of which play a crucial role in making eBPF effective and powerful.","title":"An Introduction to eBPF"},{"content":"Motivation eBPF (extended Berkeley Packet Filter) has revolutionized how we implement networking functionality in Linux systems. This comprehensive blog explores the networking concepts involved in eBPF, covering everything from fundamental principles to advanced implementations. With eBPF, developers can run sandboxed programs within the kernel space, providing unprecedented control over network traffic without compromising system stability or requiring kernel modifications.\nIntroduction to eBPF eBPF represents a significant evolution from the original Berkeley Packet Filter. Created initially for filtering network packets, eBPF has expanded into a versatile execution engine that can be leveraged for numerous use cases, with networking remaining one of its most prominent applications.\nThe Evolution of BPF to eBPF The original BPF was designed as a simple packet filtering mechanism, but its capabilities were radically expanded in 2014. The result-extended BPF or eBPF-allows programs broad access to kernel functions and system memory, but in a protected way. This expansion enables eBPF to gather detailed information about low-level networking, security, and other system-level activities within the kernel without requiring direct modifications to kernel code.\nUnlike programs that run in user space, eBPF programs are inherently more efficient and potentially more powerful because they can see and respond to nearly all operations performed by the operating system. For application tracing, eBPF provides the advantage of not requiring any code instrumentation, and since it supports event-driven functions, tracing can be performed efficiently as CPU cycles are used only when needed.\nWhy eBPF is Revolutionary for Networking eBPF has transformed network programming in Linux by:\nProviding built-in hooks for programs based on system calls, kernel functions, network events, and other triggers Offering a mechanism for compiling and verifying code prior to running, ensuring security and stability Enabling a more straightforward way to enhance kernel functionality than is possible through Loadable Kernel Modules (LKMs) These capabilities make eBPF particularly valuable for networking challenges that traditional tools struggle to address efficiently or with sufficient granularity. Because eBPF programs are event-based, they can enable efficient but complex processing of network traffic and design detailed but lightweight security and observability features.\nLinux Networking Fundamentals To understand how eBPF enhances networking, we first need to grasp the fundamentals of Linux networking architecture and how packets flow through the kernel.\nLinux Kernel Networking Stack The Linux networking stack follows a layered model similar to the OSI model but with Linux-specific adaptations. When a network packet arrives, it flows through several layers before reaching user-space applications:\nPhysical Layer: Managed by network interface card (NIC) drivers that handle the physical reception of packets Link Layer: Handles Ethernet frames and addressing Network Layer: Processes IP packets, handles routing decisions Transport Layer: Manages TCP/UDP connections and reliability Socket Interface: Connects kernel networking to userspace applications eBPF can attach to various points within this stack, allowing for unprecedented control over packet processing.\nLinux Kernel Networking Stack\nPacket Flow in Linux Understanding packet flow is crucial for effective eBPF programming. A packet typically follows this path:\nIngress Path:\nPacket arrives at the NIC XDP (eXpress Data Path) hook - earliest point for eBPF interception NIC driver processing Traffic Control (TC) ingress hook - another eBPF interception point Netfilter hooks (used by iptables) Protocol handlers (IP, TCP, UDP) Socket delivery to applications Egress Path:\nApplication sends data through socket Protocol handlers process outgoing data Routing subsystem makes forwarding decisions Netfilter hooks process outgoing packets Traffic Control (TC) egress hook - eBPF interception point NIC driver prepares packet for transmission Packet transmitted by NIC Each of these points offers opportunities for eBPF programs to intercept, analyze, modify, or redirect network traffic.\neBPF Program Types for Networking eBPF provides several program types specifically designed for different networking use cases. Each program type corresponds to a specific attachment point in the networking stack.\nSocket Filter Programs Socket filter programs (BPF_PROG_TYPE_SOCKET_FILTER) represent one of the earliest applications of BPF. These programs can hook into network sockets and are designed to filter or modify packets received by that socket. Importantly, these programs only operate on ingress (received) packets, not outgoing packets.\nSocket filter programs are called by the kernel with a __sk_buff context. The return value from these programs indicates how many bytes of the message should be kept. Returning a value less than the size of the packet will truncate it, and returning 0 will discard the packet entirely.\nA notable use case for this program type is tcpdump, which uses raw sockets in combination with socket filters generated from filter queries to efficiently process only packets of interest, minimizing the cost of kernel-userspace transitions.\nTo use socket filter programs, they are typically placed in an ELF section prefixed with socket and attached to network sockets using the setsockopt syscall with the SOL_SOCKET socket level and SO_ATTACH_BPF socket option.\nTraffic Control (TC) Programs Traffic Control (TC) is Linux\u0026rsquo;s mechanism for controlling packet sending and receiving in terms of rate, sequence, and other aspects. Located at the link layer, TC comes into play after sk_buff allocation and operates later in the processing path than XDP.\nIn the TC subsystem, the corresponding data structure and algorithm control mechanism are abstracted as qdisc (Queueing discipline). It exposes two callback interfaces for enqueuing and dequeuing packets externally while internally hiding the implementation of queuing algorithms.\nTC can implement complex tree structures based on filters and classes:\nFilters are mounted on qdisc or class to implement specific filtering logic Classes organize packets into different categories Actions are executed when packets match specific filters When a packet reaches the top-level qdisc, its enqueue interface is called, and mounted filters are executed sequentially until one matches successfully. The packet is then sent to the class pointed to by that filter and enters the qdisc processing configured for that class.\nThe TC framework with eBPF provides a classifier-action mechanism, allowing an eBPF program loaded as a filter to return values that determine packet handling, implementing a complete packet classification and processing system.\nXDP (eXpress Data Path) Programs XDP programs represent one of the most powerful networking applications of eBPF. They operate at the earliest possible point in the networking stack, before the kernel allocates memory structures for packets. This early interception enables extremely high-performance packet processing.\nXDP programs can return several actions that determine the packet\u0026rsquo;s fate:\nXDP_DROP: Tells the driver to drop packets at an early stage, which is extremely efficient for filtering and DDoS mitigation XDP_PASS: Allows packets to continue to the normal network stack XDP_TX: Forwards packets using the same NIC by which they were received XDP_REDIRECT: Forwards packets to a different network interface or CPU These capabilities make XDP ideal for high-performance networking applications such as:\nDDoS mitigation and firewalling Forwarding and load balancing Network monitoring Protocol translation cGroup Socket Programs cGroup socket programs (BPF_PROG_TYPE_CGROUP_SOCK) are attached to cGroups and triggered when sockets are created, released, or bound by a process in that cGroup. These programs allow for policy enforcement and monitoring at the socket level based on a process\u0026rsquo;s cGroup membership.\nThis program type enables fine-grained control over socket operations for processes in specific cGroups, which is particularly useful in containerized environments.\nXDP: High-Performance Packet Processing XDP (eXpress Data Path) represents one of the most transformative networking features enabled by eBPF, offering unprecedented performance for packet processing applications.\nXDP Architecture and Hook Points XDP operates directly at the driver level, intercepting packets immediately as they arrive from the network interface, before any memory allocations or other kernel processing occurs. This early interception point provides several advantages:\nMinimal Processing Overhead: Packets can be processed or dropped before the kernel allocates memory for them Reduced Latency: Fast-path operations can bypass much of the kernel\u0026rsquo;s networking stack High Throughput: XDP can process millions of packets per second on a single CPU core XDP provides several hook points for attaching eBPF programs:\nDriver/Native XDP: Implemented directly in the network driver, offering the best performance but requiring driver support Generic XDP: Runs later in the stack after the sk_buff allocation, with somewhat reduced performance but broader compatibility Offloaded XDP: Programs are offloaded to the NIC hardware, enabling wire-speed processing without CPU involvement for supported NICs XDP Actions and Use Cases XDP programs can implement various packet handling strategies through several return values:\nXDP_DROP: Instructs the driver to drop the packet immediately, which is extremely efficient for filtering and DDoS mitigation XDP_PASS: Allows the packet to continue to the normal network stack for further processing XDP_TX: Transmits the modified packet back out through the same NIC it arrived on, useful for creating simple packet responders or modifying and returning packets XDP_REDIRECT: Forwards the packet to a different network interface or to a different CPU for processing, enabling advanced use cases like load balancing or packet steering These actions make XDP particularly well-suited for several networking applications:\nDDoS Mitigation and Firewalling One of the fundamental functions of XDP is using XDP_DROP to eliminate unwanted traffic at an early stage. This capability allows for implementing various efficient network security strategies while keeping the processing cost of each packet very low.\nXDP excels at handling DDoS attacks by scrubbing illegitimate traffic and forwarding legitimate packets to their destination using XDP_TX. It can be deployed either in standalone network appliances or distributed to multiple nodes that protect the host.\nFor maximum performance, offloaded XDP can shift processing entirely to the NIC, allowing packets to be processed at wire speed.\nForwarding and Load Balancing XDP enables efficient packet forwarding and load balancing through XDP_TX or XDP_REDIRECT operations. This allows data packets to be manipulated using BPF helper functions to increase or decrease packet headroom, or to encapsulate and decapsulate packets before sending them.\nLoad balancers can be implemented using either:\nXDP_TX to forward packets using the same NIC by which they were received XDP_REDIRECT to forward packets to a different network interface Programming with XDP Creating an XDP program involves several steps:\nSetting up the development environment by installing required packages: sudo dnf install clang llvm gcc libbpf libbpf-devel libxdp libxdp-devel xdp-tools bpftool kernel-headers Writing the XDP program in C, such as a simple program to drop all packets: #include \u0026lt;linux/bpf.h\u0026gt; SEC(\u0026#34;xdp\u0026#34;) int xdp_drop(struct xdp_md *ctx) { return XDP_DROP; } Building the program using Clang: clang -O2 -g -Wall -target bpf -c xdp_drop.c -o xdp_drop.o Loading the program using appropriate tools like bpftool or xdp-loader This straightforward approach allows for rapid development and deployment of high-performance networking applications.\nTraffic Control with eBPF Traffic Control (TC) is Linux\u0026rsquo;s subsystem for controlling packet sending and receiving. With eBPF support, TC has become a powerful platform for implementing complex packet processing logic.\nTC Architecture and Components TC is located at the link layer in the Linux networking stack, operating after sk_buff allocation has been completed. The TC subsystem consists of several components:\nQueueing Disciplines (qdiscs): Algorithms that control how packets are queued and dequeued Classes: Organize packets into categories for different treatment Filters: Match packets based on criteria and assign them to classes Actions: Operations performed on packets when they match filters In the TC subsystem, the corresponding data structure and algorithm control mechanism are abstracted as qdisc (Queueing discipline). It exposes two callback interfaces for enqueuing and dequeuing packets externally while internally hiding the implementation of queuing algorithms.\nFilters and Classes in TC TC can implement complex packet processing through filters and classes:\nFilters are mounted on qdisc or class to implement specific filtering logic Classes organize packets into different categories Actions are executed when packets match specific filters When a packet reaches the top-level qdisc:\nIts enqueue interface is called Mounted filters are executed sequentially until one matches The packet is sent to the class pointed to by that filter The packet enters the qdisc processing configured for that class The TC framework with eBPF provides a classifier-action mechanism that enables both packet classification and processing in an integrated way.\nTC vs. XDP: When to Use Which While both TC and XDP enable programmable packet processing, they have different characteristics that make them suitable for different use cases:\nXDP advantages:\nProcesses packets earlier, before sk_buff allocation Higher performance for simple packet filtering and dropping Better suited for DDoS mitigation and high-throughput applications TC advantages:\nRicher context with full sk_buff access Better integration with existing traffic control mechanisms More suitable for complex packet transformation and manipulation Works with virtual interfaces and in scenarios where XDP is not supported Generally, use XDP for high-performance packet filtering and forwarding, and TC for complex traffic shaping, detailed packet manipulation, and where integration with existing QoS mechanisms is required.\neBPF Maps for Networking eBPF maps are key-value stores that allow data sharing between eBPF programs and between kernel and user space. They are crucial for networking applications, providing state storage, configuration, and inter-program communication.\nMap Types Overview Linux kernel provides numerous map types for various use cases. For networking applications, these can be categorized as:\nGeneric map types: General-purpose storage like hash tables and arrays Map-in-map types: Maps that store references to other maps Streaming maps: For large data transfer between kernel and user space Packet redirection maps: For steering packets between devices, CPUs, or sockets Special-purpose maps: For specific networking functions Hash and Array Maps These fundamental map types provide the building blocks for many networking applications:\nBPF_MAP_TYPE_HASH: A generic hash table for key-value lookups BPF_MAP_TYPE_ARRAY: An array with fixed-size entries, indexed by integers BPF_MAP_TYPE_LRU_HASH: A hash with least-recently-used eviction policy BPF_MAP_TYPE_LPM_TRIE: A longest-prefix match tree, ideal for IP routing tables These maps are commonly used for connection tracking tables, flow state storage, configuration parameters, and statistics collection.\nPer-CPU Maps Per-CPU map variants maintain separate copies of the map for each logical CPU, eliminating the need for synchronization:\nBPF_MAP_TYPE_PERCPU_HASH: Per-CPU version of hash map BPF_MAP_TYPE_PERCPU_ARRAY: Per-CPU version of array map These maps offer superior performance for high-traffic networking applications by eliminating contention between CPUs. Since multiple CPUs never read or write to memory accessed by another CPU, these maps avoid race conditions and the need for synchronization mechanisms like spin-locks or atomic instructions.\nPer-CPU maps also improve performance through better cache locality and can serve as efficient scratch buffers for temporary storage during packet processing.\nSocket Maps and Packet Redirection Maps Specialized maps designed for networking operations:\nBPF_MAP_TYPE_SOCKMAP: Stores socket references for redirection between sockets BPF_MAP_TYPE_SOCKHASH: Hash-based socket storage for efficient lookups BPF_MAP_TYPE_DEVMAP: Stores network device references for XDP redirection between interfaces BPF_MAP_TYPE_CPUMAP: Enables XDP packet redirection between CPUs for balanced processing These maps facilitate packet steering between network devices, CPUs, and sockets, enabling efficient implementation of load balancing, forwarding, and network function virtualization.\nRingbuf and Perf Event Arrays Maps that enable efficient data streaming between kernel and user space:\nBPF_MAP_TYPE_RINGBUF: A ring buffer for efficient bulk data transfer BPF_MAP_TYPE_PERF_EVENT_ARRAY: Uses perf subsystem for event notification For networking applications, these maps are valuable for packet sampling and capture, network telemetry and monitoring, flow record export, and network analytics.\nMap-in-Map Structures Map-in-map types store references to other maps, enabling complex data structures:\nBPF_MAP_TYPE_ARRAY_OF_MAPS: An array where each element is a map BPF_MAP_TYPE_HASH_OF_MAPS: A hash table where values are maps These structures enable sophisticated networking applications like multi-level routing tables, hierarchical policy enforcement, and tenant isolation in multi-tenant networks.\nSocket Filtering and Manipulation Socket filtering is one of the original use cases for BPF and continues to be a powerful application of eBPF. Socket filters allow programs to inspect and filter packets at the socket level, providing an efficient way to process only relevant network traffic.\nSocket Filter Programs Socket filter programs (BPF_PROG_TYPE_SOCKET_FILTER) are designed to filter or modify packets received by network sockets. These programs hook into network sockets but only operate on ingress (received) packets, not egress (outgoing) packets.\nSocket filter programs are called by the kernel with a __sk_buff context, and their return value indicates how many bytes of the message should be kept. Returning a value less than the size of the packet truncates it, while returning 0 discards the packet completely.\nA common use case for socket filters is tcpdump, which uses raw sockets with socket filters generated from filter queries to efficiently process only packets of interest, minimizing the kernel-userspace barrier cost.\nSocket filter programs are typically placed in an ELF section prefixed with socket and attached to network sockets using the setsockopt syscall with SOL_SOCKET socket level and SO_ATTACH_BPF socket option.\nHelper Functions for Socket Programs Socket filter programs can use various helper functions to interact with the system and the context in which they operate. Some of the helper functions available to socket filter programs include:\nbpf_get_socket_cookie bpf_get_socket_uid bpf_ktime_get_ns bpf_map_lookup_elem bpf_map_update_elem bpf_perf_event_output bpf_get_current_pid_tgid bpf_get_current_task These helpers enable socket filter programs to access various information about sockets, processes, and system state, enhancing their capabilities for packet processing and analysis.\nSocket Map Usage eBPF provides special map types for socket operations:\nBPF_MAP_TYPE_SOCKMAP: Stores references to sockets for redirection BPF_MAP_TYPE_SOCKHASH: A hash-based version of SOCKMAP for efficient lookups These maps enable advanced socket operations like fast socket lookup based on connection information, efficient socket redirection, and socket message forwarding between sockets.\nPacket Redirection and Forwarding Packet redirection is a powerful capability of eBPF that allows packets to be steered between interfaces, CPUs, and sockets without traversing the entire networking stack. This capability enables efficient implementation of networking functions like load balancing, forwarding, and NAT.\nInterface Redirection with XDP XDP allows packets to be redirected between network interfaces using the BPF_MAP_TYPE_DEVMAP and the bpf_redirect_map() helper function. This capability enables:\nSoftware-defined networking Virtual switching Service chaining Policy-based routing Interface redirection typically involves:\nDetermining the target interface based on packet attributes or policy Looking up the interface in a DEVMAP Using XDP_REDIRECT action with appropriate helper function CPU Redirection CPU redirection allows packets to be distributed across CPU cores for balanced processing:\nXDP CPU Redirection: Using BPF_MAP_TYPE_CPUMAP and the bpf_redirect_map() helper RSS (Receive Side Scaling): Hardware-based distribution that can be influenced by eBPF CPU redirection enables load balancing across cores, processor affinity for related flows, and optimization of cache locality.\nImplementing Load Balancing XDP is particularly well-suited for implementing load balancers:\nL3/L4 Load Balancing: Based on IP addresses and ports Extract flow information (IPs, ports) Compute consistent hash Select backend using hash Redirect to selected backend using XDP_TX or XDP_REDIRECT L7 Load Balancing: Based on application-layer information Parse HTTP/gRPC/etc. headers Apply load balancing logic based on content Redirect to appropriate backend Load balancers can be implemented using either:\nXDP_TX to forward packets using the same NIC by which they were received XDP_REDIRECT to forward packets to a different network interface Network Monitoring and Observability eBPF provides unprecedented capabilities for network monitoring and observability, enabling detailed visibility into network behavior without modifying applications or introducing significant overhead.\nTracing Network Functions eBPF can trace network-related kernel functions to provide insights into network behavior:\nKprobe-based tracing: Attaching eBPF programs to entry and exit points of kernel networking functions Tracepoint-based tracing: Using predefined tracepoints in the networking stack Raw tracepoints: Lower-overhead alternatives to standard tracepoints These tracing mechanisms enable detailed function call tracking, parameter inspection, performance analysis, and debugging of network issues.\nSocket Monitoring eBPF programs can monitor socket operations to provide insights into application network behavior:\nSocket creation and binding: Tracking when sockets are created and bound to addresses Connection establishment: Monitoring TCP connection setup and teardown Data transfer: Measuring throughput and patterns of data flow Error conditions: Detecting socket errors and failures This monitoring provides valuable insights into application networking behavior and performance.\nFlow Monitoring eBPF facilitates detailed flow monitoring at wire speed:\nFlow identification: Based on 5-tuple (IPs, ports, protocol) Flow statistics: Packets, bytes, duration Flow behavior analysis: Patterns, protocols, periodicity Flow sampling: Efficient collection of representative data Flow monitoring applications include:\nTraffic accounting Anomaly detection Capacity planning Application dependency mapping Security Applications of eBPF Networking eBPF has revolutionized network security by enabling programmable, high-performance security functions directly in the kernel.\nFirewalling with eBPF eBPF enables next-generation firewall capabilities:\nXDP-based firewalling: Ultra-fast packet filtering at the driver level, ideal for volumetric attack mitigation Stateful firewalling: Using eBPF maps to track connection state Dynamic rule updates: Modifying firewall behavior without service disruption Using XDP_DROP with eBPF allows for implementing firewall policies with very little overhead per packet, making it extremely efficient for filtering large volumes of traffic.\nDDoS Mitigation Strategies eBPF is particularly effective for DDoS mitigation:\nEarly packet dropping: Using XDP to drop attack traffic before it consumes system resources Traffic classification: Distinguishing legitimate from attack traffic Rate limiting: Implementing per-source rate limiting to contain attacks XDP can handle DDoS scenarios by scrubbing illegitimate traffic and forwarding legitimate packets to their destination using XDP_TX. This approach can be implemented either in standalone network appliances or distributed across multiple nodes that protect the host.\nFor maximum performance, offloaded XDP can shift processing entirely to the NIC, allowing packets to be processed at wire speed.\nConclusion In this first part of our deep dive into networking with eBPF, we explored the fundamental building blocks that make eBPF a game-changer for modern networking on Linux. Starting with a historical evolution from classic BPF to the powerful eBPF framework, we examined how eBPF empowers developers to gain unprecedented control over packet flow within the kernel without compromising stability or requiring kernel modifications.\nWe navigated the Linux networking stack to understand where and how eBPF programs can be attached. We covered various eBPF program types such as socket filters, traffic control programs, XDP for high-performance packet processing, and cGroup socket programs. Each of these offers unique capabilities tailored to different networking needs.\nWe also delved into the rich landscape of eBPF maps that underpin stateful packet processing and data sharing, from basic hash maps to advanced per-CPU and redirection maps. Furthermore, we covered packet redirection strategies, load balancing techniques, observability through tracing and monitoring, and security applications including DDoS mitigation and firewalling—all achieved using eBPF’s flexible and performant architecture.\neBPF is redefining what’s possible in networking—bringing high throughput, fine-grained control, and programmability directly into the kernel. In the next part of this series, we’ll go deeper into real-world use cases, practical implementation patterns, and performance tuning techniques to harness the full potential of eBPF in production environments.\n","permalink":"http://localhost:1313/blog/ebpf/networking-with-ebpf/","summary":"Motivation eBPF (extended Berkeley Packet Filter) has revolutionized how we implement networking functionality in Linux systems. This comprehensive blog explores the networking concepts involved in eBPF, covering everything from fundamental principles to advanced implementations. With eBPF, developers can run sandboxed programs within the kernel space, providing unprecedented control over network traffic without compromising system stability or requiring kernel modifications.\nIntroduction to eBPF eBPF represents a significant evolution from the original Berkeley Packet Filter.","title":"Networking with eBPF: From Fundamentals to Advanced Applications"},{"content":"1. BTF (BPF Type Format) Functions Function Name Purpose Parameters Return Type When to Use Detailed Explanation bpf_btf_get_fd_by_id Get BTF file descriptor by ID __u32 id int When you need to access BTF object with known ID Returns file descriptor for BTF object with given ID. Useful for introspection tools to examine type information of loaded programs[^1] bpf_btf_get_fd_by_id_opts Get BTF file descriptor by ID with options __u32 id, const struct bpf_get_fd_by_id_opts *opts int When you need BTF access with specific options Extended version with options like token_fd for permission delegation bpf_btf_get_info_by_fd Get BTF information by file descriptor int btf_fd, struct bpf_btf_info *info, __u32 *info_len int When you need metadata about BTF object Populates BTF object information structure with metadata like name, BTF data size, etc.[^2] bpf_btf_get_next_id Get next BTF ID __u32 start_id, __u32 *next_id int For iterating through all BTF objects Used by introspection tools to enumerate all loaded BTF objects in the system bpf_btf_load Load BTF data into kernel const void *btf_data, size_t btf_size, struct bpf_btf_load_opts *opts int When loading BTF type information Loads BTF blob into kernel, returns BTF file descriptor for use with maps and programs btf__new Create new BTF object from raw data const void *data, __u32 size struct btf * When parsing BTF from ELF or raw bytes Creates BTF object instance from raw BTF section data, used during program loading[^2] btf__free Free BTF object struct btf *btf void When cleaning up BTF resources Frees all memory associated with BTF object, should be called for every btf__new()[^2] btf__load_into_kernel Load BTF into kernel struct btf *btf int When making BTF available to kernel Uploads BTF object to kernel, making it available for program verification and map creation btf__parse Parse BTF from file const char *path, struct btf_ext **btf_ext struct btf * When loading BTF from ELF file Parses BTF section from ELF file, commonly used with compiled BPF programs 2. BPF Link Management Functions Function Name Purpose Parameters Return Type When to Use Detailed Explanation bpf_link__destroy Destroy BPF link struct bpf_link *link int When detaching and cleaning up program Detaches program from kernel hook and frees all associated resources[^3] bpf_link__detach Detach BPF link struct bpf_link *link int When you want to detach but keep link object Detaches program from hook point but preserves link object for potential reuse bpf_link__disconnect Disconnect BPF link struct bpf_link *link void When severing link connection Disconnects link from underlying kernel attachment without destroying the object bpf_link__fd Get link file descriptor const struct bpf_link *link int When you need raw FD for operations Returns underlying file descriptor for direct syscall operations bpf_link__open Open existing link from filesystem const char *path struct bpf_link * When loading pinned link Opens previously pinned link from BPF filesystem bpf_link__pin Pin link to filesystem struct bpf_link *link, const char *path int When persisting link beyond process lifetime Pins link to BPF filesystem, allowing it to persist after process exits[^2] bpf_link__pin_path Get pin path of link const struct bpf_link *link const char * When checking where link is pinned Returns filesystem path where link is pinned, NULL if not pinned bpf_link__unpin Unpin link from filesystem struct bpf_link *link int When removing persisted link Removes link from filesystem, decrementing reference count bpf_link__update_map Update map associated with link struct bpf_link *link, const struct bpf_map *map int When changing map for struct_ops Updates the map associated with struct_ops link to different map bpf_link__update_program Update program in link struct bpf_link *link, struct bpf_program *prog int When hot-swapping programs Atomically replaces program in existing link without recreating attachment bpf_link_create Create new BPF link int prog_fd, int target_fd, enum bpf_attach_type attach_type, const struct bpf_link_create_opts *opts int When you need low-level link control Low-level wrapper around BPF_LINK_CREATE syscall for precise control[^4] bpf_link_detach Detach link by FD int link_fd int When detaching using raw file descriptor Detaches link using its file descriptor directly bpf_link_get_fd_by_id Get link FD by ID __u32 id int When accessing link with known ID Returns file descriptor for link with specified ID bpf_link_get_fd_by_id_opts Get link FD by ID with options __u32 id, const struct bpf_get_fd_by_id_opts *opts int When accessing link with options Extended version with additional options like token_fd bpf_link_get_info_by_fd Get link information int link_fd, struct bpf_link_info *info, __u32 *info_len int When querying link metadata Retrieves link information including type, program ID, and attach information bpf_link_get_next_id Get next link ID __u32 start_id, __u32 *next_id int For enumerating all links Used by introspection tools to iterate through all links in system bpf_link_update Update existing link int link_fd, int new_prog_fd, const struct bpf_link_update_opts *opts int When replacing program in link Updates link to use different program, useful for program hot-swapping 3. BPF Map Functions Function Name Purpose Parameters Return Type When to Use Detailed Explanation bpf_map__attach_struct_ops Attach struct_ops map const struct bpf_map *map struct bpf_link * When using struct_ops maps Attaches struct_ops map to kernel subsystem, enabling callback function registration bpf_map__autoattach Check if map auto-attaches const struct bpf_map *map bool When checking map attachment behavior Returns whether map will automatically attach during skeleton attach phase bpf_map__autocreate Check if map auto-creates const struct bpf_map *map bool When checking map creation behavior Returns whether map will be automatically created during object load bpf_map__btf_key_type_id Get BTF key type ID const struct bpf_map *map __u32 When working with typed maps Returns BTF type ID for map key, enabling type-aware operations bpf_map__btf_value_type_id Get BTF value type ID const struct bpf_map *map __u32 When working with typed maps Returns BTF type ID for map value, used for type verification bpf_map__delete_elem Delete map element const struct bpf_map *map, const void *key, size_t key_sz, __u64 flags int When removing key-value pairs High-level wrapper for deleting map elements with size validation[^2] bpf_map__fd Get map file descriptor const struct bpf_map *map int When you need raw FD for operations Returns underlying file descriptor for direct map operations[^2] bpf_map__get_next_key Get next key in map const struct bpf_map *map, const void *cur_key, void *next_key, size_t key_sz int When iterating through map keys Retrieves next key for map iteration, returns -ENOENT when reaching end[^2] bpf_map__get_pin_path Get map pin path const struct bpf_map *map const char * When checking map persistence Returns filesystem path where map is pinned, NULL if not pinned bpf_map__ifindex Get map network interface index const struct bpf_map *map __u32 When working with device maps Returns network interface index for device-specific maps bpf_map__initial_value Get map initial value const struct bpf_map *map, size_t *psize void * When accessing global data Returns pointer to initial data for global variable maps (bss, data, rodata) bpf_map__inner_map Get inner map template struct bpf_map *map struct bpf_map * When working with map-in-map Returns template map for map-in-map types (array of maps, hash of maps) bpf_map__is_internal Check if map is internal const struct bpf_map *map bool When filtering map types Returns true for internal maps created by libbpf (global vars, externs)[^2] bpf_map__is_pinned Check if map is pinned const struct bpf_map *map bool When checking map persistence Returns whether map is currently pinned to filesystem[^2] bpf_map__key_size Get map key size const struct bpf_map *map __u32 When validating key sizes Returns size in bytes of map keys bpf_map__lookup_and_delete_elem Lookup and delete atomically const struct bpf_map *map, const void *key, size_t key_sz, void *value, size_t value_sz, __u64 flags int When implementing queues/stacks Atomically retrieves and removes element, useful for FIFO/LIFO operations[^2] bpf_map__lookup_elem Lookup map element const struct bpf_map *map, const void *key, size_t key_sz, void *value, size_t value_sz, __u64 flags int When reading map values High-level wrapper for map lookups with size validation[^2] bpf_map__map_extra Get map extra parameters const struct bpf_map *map __u64 When accessing map-specific data Returns map-specific extra data (bloom filter hash count, etc.) bpf_map__map_flags Get map flags const struct bpf_map *map __u32 When checking map properties Returns map creation flags (NO_PREALLOC, NUMA_NODE, etc.) bpf_map__max_entries Get maximum entries const struct bpf_map *map __u32 When checking map capacity Returns maximum number of entries the map can hold bpf_map__name Get map name const struct bpf_map *map const char * When identifying maps Returns name of the map as defined in BPF program bpf_map__numa_node Get NUMA node const struct bpf_map *map __u32 When checking NUMA placement Returns NUMA node where map memory is allocated bpf_map__pin Pin map to filesystem struct bpf_map *map, const char *path int When persisting maps Pins map to BPF filesystem for persistence beyond process lifetime[^2] bpf_map__pin_path Get pin path const struct bpf_map *map const char * When checking pin location Returns filesystem path where map is pinned[^2] bpf_map__reuse_fd Reuse existing map FD struct bpf_map *map, int fd int When sharing maps between processes Makes map object use existing file descriptor instead of creating new map bpf_map__set_autoattach Set auto-attach behavior struct bpf_map *map, bool autoattach int When controlling attachment Sets whether map automatically attaches during skeleton attach phase bpf_map__set_autocreate Set auto-create behavior struct bpf_map *map, bool autocreate int When controlling creation Sets whether map is automatically created during object load[^2] bpf_map__set_ifindex Set network interface index struct bpf_map *map, __u32 ifindex int When binding to specific device Sets network interface for device-specific maps bpf_map__set_initial_value Set initial map value struct bpf_map *map, const void *data, size_t size int When initializing global data Sets initial data for global variable maps bpf_map__set_inner_map_fd Set inner map FD struct bpf_map *map, int fd int When configuring map-in-map Sets template map for map-in-map types bpf_map__set_key_size Set key size struct bpf_map *map, __u32 size int When configuring map before load Sets size of map keys, must be called before object load bpf_map__set_map_extra Set map extra parameters struct bpf_map *map, __u64 map_extra int When setting map-specific options Sets map-specific extra parameters bpf_map__set_map_flags Set map flags struct bpf_map *map, __u32 flags int When configuring map behavior Sets map creation flags before load bpf_map__set_max_entries Set maximum entries struct bpf_map *map, __u32 max_entries int When sizing maps Sets maximum number of entries, must be called before load bpf_map__set_numa_node Set NUMA node struct bpf_map *map, __u32 numa_node int When optimizing memory placement Sets NUMA node for map memory allocation bpf_map__set_pin_path Set pin path struct bpf_map *map, const char *path int When configuring persistence Sets filesystem path for map pinning[^2] bpf_map__set_type Set map type struct bpf_map *map, enum bpf_map_type type int When changing map type Changes map type, must be called before object load bpf_map__set_value_size Set value size struct bpf_map *map, __u32 size int When configuring value size Sets size of map values, can resize global data sections[^2] bpf_map__type Get map type const struct bpf_map *map enum bpf_map_type When checking map type Returns the type of the map (HASH, ARRAY, etc.) bpf_map__unpin Unpin map from filesystem struct bpf_map *map, const char *path int When removing persistence Removes map from filesystem, decrementing reference count[^2] bpf_map__update_elem Update map element const struct bpf_map *map, const void *key, size_t key_sz, const void *value, size_t value_sz, __u64 flags int When writing to maps High-level wrapper for map updates with size validation[^2] bpf_map__value_size Get value size const struct bpf_map *map __u32 When validating value sizes Returns size in bytes of map values bpf_map_create Create new map enum bpf_map_type map_type, const char *map_name, __u32 key_size, __u32 value_size, __u32 max_entries, const struct bpf_map_create_opts *opts int When creating maps programmatically Low-level map creation with precise control over all parameters[^5] 4. BPF Object Functions Function Name Purpose Parameters Return Type When to Use Detailed Explanation bpf_object__attach_skeleton Attach skeleton programs struct bpf_object_skeleton *s int When using skeleton-based loading Attaches all programs in skeleton to their respective hook points bpf_object__btf Get object\u0026rsquo;s BTF const struct bpf_object *obj struct btf * When accessing type information Returns BTF object associated with BPF object for type introspection bpf_object__btf_fd Get BTF file descriptor const struct bpf_object *obj int When you need BTF FD Returns file descriptor of BTF object associated with BPF object bpf_object__close Close BPF object struct bpf_object *obj void When cleaning up Frees all resources associated with BPF object[^2] bpf_object__destroy_skeleton Destroy skeleton struct bpf_object_skeleton *s void When cleaning up skeleton Frees all skeleton resources including maps, programs, and links bpf_object__destroy_subskeleton Destroy subskeleton struct bpf_object_subskeleton *s void When cleaning up subskeleton Frees subskeleton resources for partial object access bpf_object__detach_skeleton Detach skeleton programs struct bpf_object_skeleton *s void When detaching all programs Detaches all programs in skeleton from their hook points bpf_object__find_map_by_name Find map by name const struct bpf_object *obj, const char *name struct bpf_map * When accessing specific maps Locates map within object by name, returns NULL if not found[^2] bpf_object__find_map_fd_by_name Find map FD by name const struct bpf_object *obj, const char *name int When you need map FD directly Returns file descriptor of named map, -1 if not found bpf_object__find_program_by_name Find program by name const struct bpf_object *obj, const char *name struct bpf_program * When accessing specific programs Locates program within object by name bpf_object__gen_loader Generate loader program struct bpf_object *obj, struct gen_loader_opts *opts int When creating loader programs Generates BPF program that can load the object at runtime bpf_object__kversion Get kernel version const struct bpf_object *obj unsigned int When checking version requirements Returns kernel version the object was compiled for bpf_object__load Load object into kernel struct bpf_object *obj int When loading all programs and maps Loads all programs and maps in object into kernel[^2] bpf_object__load_skeleton Load skeleton struct bpf_object_skeleton *s int When using skeleton loading Loads all skeleton components into kernel bpf_object__name Get object name const struct bpf_object *obj const char * When identifying objects Returns name of the BPF object bpf_object__next_map Get next map const struct bpf_object *obj, const struct bpf_map *map struct bpf_map * When iterating through maps Iterates through all maps in object, NULL to start bpf_object__next_program Get next program const struct bpf_object *obj, struct bpf_program *prog struct bpf_program * When iterating through programs Iterates through all programs in object, NULL to start bpf_object__open Open BPF object file const char *path struct bpf_object * When loading from ELF file Opens and parses BPF ELF object file[^2] bpf_object__open_file Open with options const char *path, const struct bpf_object_open_opts *opts struct bpf_object * When you need open options Extended open with options like BTF custom path[^6] bpf_object__open_mem Open from memory const void *obj_buf, size_t obj_buf_sz, const struct bpf_object_open_opts *opts struct bpf_object * When loading from memory buffer Opens BPF object from memory buffer instead of file[^2] bpf_object__open_skeleton Open skeleton struct bpf_object_skeleton *s, const struct bpf_object_open_opts *opts int When using skeleton loading Opens skeleton object with specified options bpf_object__open_subskeleton Open subskeleton struct bpf_object_subskeleton *s int When accessing partial object Opens subskeleton for accessing subset of object components bpf_object__pin Pin entire object struct bpf_object *object, const char *path int When persisting entire object Pins all maps and programs in object to filesystem directory bpf_object__pin_maps Pin all maps struct bpf_object *obj, const char *path int When persisting maps only Pins all maps in object to specified directory[^2] bpf_object__pin_programs Pin all programs struct bpf_object *obj, const char *path int When persisting programs Pins all programs in object to filesystem directory bpf_object__prev_map Get previous map const struct bpf_object *obj, const struct bpf_map *map struct bpf_map * When reverse-iterating maps Reverse iteration through maps in object bpf_object__prev_program Get previous program const struct bpf_object *obj, struct bpf_program *prog struct bpf_program * When reverse-iterating programs Reverse iteration through programs in object bpf_object__set_kversion Set kernel version struct bpf_object *obj, __u32 kern_version int When targeting specific kernel Sets target kernel version for compatibility bpf_object__token_fd Get token file descriptor const struct bpf_object *obj int When using delegation tokens Returns BPF token FD for permission delegation[^2] bpf_object__unpin Unpin entire object struct bpf_object *object, const char *path int When removing object persistence Unpins all object components from filesystem bpf_object__unpin_maps Unpin all maps struct bpf_object *obj, const char *path int When removing map persistence Unpins all maps from filesystem directory[^2] bpf_object__unpin_programs Unpin all programs struct bpf_object *obj, const char *path int When removing program persistence Unpins all programs from filesystem directory 5. BPF Program Functions Function Name Purpose Parameters Return Type When to Use Detailed Explanation bpf_program__attach Generic program attachment const struct bpf_program *prog struct bpf_link * When using auto-detection Automatically detects program type and attaches appropriately[^2] bpf_program__attach_cgroup Attach to cgroup const struct bpf_program *prog, int cgroup_fd struct bpf_link * When filtering cgroup operations Attaches program to cgroup for network or process filtering bpf_program__attach_freplace Attach as function replacement const struct bpf_program *prog, int target_fd, const char *attach_func_name struct bpf_link * When replacing kernel functions Replaces existing BPF program function with new implementation bpf_program__attach_iter Attach to iterator const struct bpf_program *prog, const struct bpf_iter_attach_opts *opts struct bpf_link * When creating BPF iterators Attaches program to BPF iterator for custom data traversal bpf_program__attach_kprobe Attach to kernel probe const struct bpf_program *prog, bool retprobe, const char *func_name struct bpf_link * When tracing kernel functions Attaches to kernel function entry or exit for tracing[^7] bpf_program__attach_kprobe_multi_opts Attach to multiple kprobes const struct bpf_program *prog, const char *pattern, const struct bpf_kprobe_multi_opts *opts struct bpf_link * When tracing multiple functions Attaches to multiple kernel functions matching pattern bpf_program__attach_kprobe_opts Attach kprobe with options const struct bpf_program *prog, const char *func_name, const struct bpf_kprobe_opts *opts struct bpf_link * When you need kprobe options Extended kprobe attachment with custom options like offset, cookie[^8] bpf_program__attach_ksyscall Attach to system call const struct bpf_program *prog, const char *syscall_name, const struct bpf_ksyscall_opts *opts struct bpf_link * When tracing system calls Attaches to kernel system call handlers with arch-independence[^2] bpf_program__attach_lsm Attach to LSM hook const struct bpf_program *prog struct bpf_link * When implementing security policies Attaches to Linux Security Module hooks for security enforcement bpf_program__attach_netfilter Attach to netfilter const struct bpf_program *prog, const struct bpf_netfilter_opts *opts struct bpf_link * When filtering network packets Attaches to netfilter hooks for packet filtering bpf_program__attach_netkit Attach to netkit device const struct bpf_program *prog, int ifindex, const struct bpf_netkit_opts *opts struct bpf_link * When working with netkit devices Attaches program to netkit virtual network device bpf_program__attach_netns Attach to network namespace const struct bpf_program *prog, int netns_fd struct bpf_link * When filtering per-netns Attaches program to specific network namespace bpf_program__attach_perf_event Attach to perf event const struct bpf_program *prog, int pfd struct bpf_link * When monitoring performance Attaches to perf event for performance monitoring bpf_program__attach_perf_event_opts Attach to perf event with options const struct bpf_program *prog, int pfd, const struct bpf_perf_event_opts *opts struct bpf_link * When you need perf options Extended perf event attachment with custom options bpf_program__attach_raw_tracepoint Attach to raw tracepoint const struct bpf_program *prog, const char *tp_name struct bpf_link * When you need low-latency tracing Attaches to raw kernel tracepoints for minimal overhead bpf_program__attach_raw_tracepoint_opts Attach raw tracepoint with options const struct bpf_program *prog, const char *tp_name, struct bpf_raw_tracepoint_opts *opts struct bpf_link * When you need raw tracepoint options Extended raw tracepoint with additional options bpf_program__attach_sockmap Attach to socket map const struct bpf_program *prog, int map_fd struct bpf_link * When redirecting sockets Attaches program to socket map for socket redirection bpf_program__attach_tcx Attach to TC express const struct bpf_program *prog, int ifindex, const struct bpf_tcx_opts *opts struct bpf_link * When using TC express datapath Attaches to traffic control express path for high-performance packet processing bpf_program__attach_trace Attach tracing program const struct bpf_program *prog struct bpf_link * When tracing with fentry/fexit Attaches tracing programs like fentry, fexit, fmod_ret bpf_program__attach_trace_opts Attach trace with options const struct bpf_program *prog, const struct bpf_trace_opts *opts struct bpf_link * When you need trace options Extended tracing attachment with additional options bpf_program__attach_tracepoint Attach to tracepoint const struct bpf_program *prog, const char *tp_category, const char *tp_name struct bpf_link * When tracing specific events Attaches to kernel tracepoints for event monitoring bpf_program__attach_tracepoint_opts Attach tracepoint with options const struct bpf_program *prog, const char *tp_category, const char *tp_name, const struct bpf_tracepoint_opts *opts struct bpf_link * When you need tracepoint options Extended tracepoint attachment with custom options bpf_program__attach_uprobe Attach to user probe const struct bpf_program *prog, bool retprobe, pid_t pid, const char *binary_path, size_t func_offset struct bpf_link * When tracing userspace functions Attaches to userspace function for application tracing[^2] bpf_program__attach_uprobe_multi Attach to multiple uprobes const struct bpf_program *prog, pid_t pid, const char *binary_path, const char *func_pattern, const struct bpf_uprobe_multi_opts *opts struct bpf_link * When tracing multiple user functions Attaches to multiple userspace functions matching pattern[^2] bpf_program__attach_uprobe_opts Attach uprobe with options const struct bpf_program *prog, pid_t pid, const char *binary_path, size_t func_offset, const struct bpf_uprobe_opts *opts struct bpf_link * When you need uprobe options Extended uprobe attachment with custom options[^2] bpf_program__attach_usdt Attach to USDT probe const struct bpf_program *prog, pid_t pid, const char *binary_path, const char *usdt_provider, const char *usdt_name, const struct bpf_usdt_opts *opts struct bpf_link * When tracing USDT probes Attaches to User Statically Defined Tracepoints[^2] bpf_program__attach_xdp Attach to XDP const struct bpf_program *prog, int ifindex struct bpf_link * When processing packets at driver level Attaches XDP program to network interface for early packet processing bpf_program__autoattach Check auto-attach status const struct bpf_program *prog bool When checking attachment behavior Returns whether program will auto-attach during skeleton attach bpf_program__autoload Check auto-load status const struct bpf_program *prog bool When checking load behavior Returns whether program will be loaded automatically bpf_program__expected_attach_type Get expected attach type const struct bpf_program *prog enum bpf_attach_type When querying attach requirements Returns the expected attachment type for the program bpf_program__fd Get program file descriptor const struct bpf_program *prog int When you need raw FD Returns underlying file descriptor for direct operations bpf_program__flags Get program flags const struct bpf_program *prog __u32 When checking program properties Returns program load flags bpf_program__get_expected_attach_type Get expected attach type const struct bpf_program *prog enum bpf_attach_type When querying attachment requirements Alias for bpf_program__expected_attach_type bpf_program__get_type Get program type const struct bpf_program *prog enum bpf_prog_type When checking program type Returns the BPF program type bpf_program__insn_cnt Get instruction count const struct bpf_program *prog size_t When analyzing program size Returns number of BPF instructions in program[^9] bpf_program__insns Get program instructions const struct bpf_program *prog const struct bpf_insn * When analyzing program code Returns pointer to BPF instruction array[^9] bpf_program__log_buf Get program log buffer const struct bpf_program *prog, size_t *log_size const char * When debugging program loading Returns verifier log buffer for debugging bpf_program__log_level Get log level const struct bpf_program *prog __u32 When checking debug settings Returns current verifier log level bpf_program__name Get program name const struct bpf_program *prog const char * When identifying programs Returns name of the BPF program bpf_program__pin Pin program to filesystem struct bpf_program *prog, const char *path int When persisting programs Pins program to BPF filesystem for persistence[^2] bpf_program__section_name Get section name const struct bpf_program *prog const char * When checking program source Returns ELF section name where program was defined bpf_program__set_attach_target Set attach target struct bpf_program *prog, int attach_prog_fd, const char *attach_func_name int When setting BTF attach targets Sets target for BTF-aware programs (fentry, fexit, etc.)[^2] bpf_program__set_autoattach Set auto-attach behavior struct bpf_program *prog, bool autoattach void When controlling attachment Sets whether program auto-attaches during skeleton attach bpf_program__set_autoload Set auto-load behavior struct bpf_program *prog, bool autoload int When controlling loading Sets whether program loads automatically bpf_program__set_expected_attach_type Set expected attach type struct bpf_program *prog, enum bpf_attach_type type int When configuring attachment Sets expected attachment type for program[^2] bpf_program__set_flags Set program flags struct bpf_program *prog, __u32 flags int When configuring load behavior Sets program loading flags bpf_program__set_ifindex Set interface index struct bpf_program *prog, __u32 ifindex void When targeting specific interfaces Sets network interface index for device-specific programs bpf_program__set_insns Set program instructions struct bpf_program *prog, struct bpf_insn *new_insns, size_t new_insn_cnt int When modifying program code Replaces program instructions (advanced use only)[^2] bpf_program__set_log_buf Set log buffer struct bpf_program *prog, char *log_buf, size_t log_size int When capturing verifier output Sets buffer for verifier log messages bpf_program__set_log_level Set log level struct bpf_program *prog, __u32 log_level int When configuring debug output Sets verifier log verbosity level bpf_program__set_type Set program type struct bpf_program *prog, enum bpf_prog_type type int When changing program type Sets BPF program type, must be called before load[^2] bpf_program__type Get program type const struct bpf_program *prog enum bpf_prog_type When checking program type Returns the BPF program type bpf_program__unload Unload program struct bpf_program *prog void When removing from kernel Removes program from kernel, making it loadable again bpf_program__unpin Unpin program struct bpf_program *prog, const char *path int When removing persistence Removes program from filesystem[^2] 6. Ring Buffer Functions Function Name Purpose Parameters Return Type When to Use Detailed Explanation ring_buffer__new Create ring buffer manager int map_fd, ring_buffer_sample_fn sample_cb, void *ctx, const struct ring_buffer_opts *opts struct ring_buffer * When setting up efficient data transfer Creates ring buffer manager for high-performance data streaming from kernel to userspace[^10] ring_buffer__free Free ring buffer struct ring_buffer *rb void When cleaning up Frees all resources associated with ring buffer manager ring_buffer__add Add ring buffer struct ring_buffer *rb, int map_fd, ring_buffer_sample_fn sample_cb, void *ctx int When managing multiple ring buffers Adds additional ring buffer to existing manager ring_buffer__poll Poll for data struct ring_buffer *rb, int timeout_ms int When waiting for data Polls ring buffer for new data with timeout ring_buffer__consume Consume available data struct ring_buffer *rb int When processing all available data Consumes all available data without blocking ring_buffer__consume_n Consume N records struct ring_buffer *rb, size_t n int When limiting processing Consumes up to N records from ring buffer ring_buffer__epoll_fd Get epoll file descriptor const struct ring_buffer *rb int When integrating with event loops Returns FD for epoll integration in event-driven applications ring_buffer__ring Get individual ring struct ring_buffer *rb, unsigned int idx struct ring * When accessing specific rings Returns specific ring buffer instance from manager[^2] user_ring_buffer__new Create user ring buffer int map_fd, const struct user_ring_buffer_opts *opts struct user_ring_buffer * When userspace needs to send data to kernel Creates ring buffer for userspace-to-kernel communication[^2] user_ring_buffer__reserve Reserve buffer space struct user_ring_buffer *rb, __u32 size void * When writing to ring buffer Reserves space in ring buffer for writing data[^2] user_ring_buffer__reserve_blocking Reserve with blocking struct user_ring_buffer *rb, __u32 size, int timeout_ms void * When blocking until space available Blocks until space becomes available in ring buffer[^2] user_ring_buffer__submit Submit reserved data struct user_ring_buffer *rb, void *sample void When finalizing data write Submits previously reserved data to ring buffer[^2] user_ring_buffer__discard Discard reserved data struct user_ring_buffer *rb, void *sample void When canceling write operation Discards previously reserved space without writing[^2] user_ring_buffer__free Free user ring buffer struct user_ring_buffer *rb void When cleaning up Frees user ring buffer resources[^2] 7. Performance Buffer Functions Function Name Purpose Parameters Return Type When to Use Detailed Explanation perf_buffer__new Create performance buffer int map_fd, size_t page_cnt, perf_buffer_sample_fn sample_cb, perf_buffer_lost_fn lost_cb, void *ctx, const struct perf_buffer_opts *opts struct perf_buffer * When using perf events for data transfer Creates performance event buffer for kernel-to-userspace communication[^11] perf_buffer__new_raw Create raw performance buffer int map_fd, size_t page_cnt, struct perf_event_attr *attr, perf_buffer_event_fn event_cb, void *ctx, const struct perf_buffer_raw_opts *opts struct perf_buffer * When you need custom perf event attributes Creates perf buffer with custom performance event configuration perf_buffer__free Free performance buffer struct perf_buffer *pb void When cleaning up Frees all performance buffer resources perf_buffer__epoll_fd Get epoll file descriptor const struct perf_buffer *pb int When integrating with event loops Returns FD for epoll integration perf_buffer__poll Poll for events struct perf_buffer *pb, int timeout_ms int When waiting for perf events Polls performance buffer for new events perf_buffer__consume Consume all events struct perf_buffer *pb int When processing all available events Consumes all available events without blocking perf_buffer__consume_buffer Consume specific buffer struct perf_buffer *pb, size_t buf_idx int When processing specific CPU buffer Consumes events from specific per-CPU buffer perf_buffer__buffer_cnt Get buffer count const struct perf_buffer *pb size_t When checking buffer configuration Returns number of per-CPU buffers perf_buffer__buffer_fd Get buffer file descriptor const struct perf_buffer *pb, size_t buf_idx int When accessing specific buffer FD Returns FD for specific per-CPU buffer perf_buffer__buffer Get raw buffer data struct perf_buffer *pb, int buf_idx, void **buf, size_t *buf_size int When implementing custom event processing Returns raw mmap\u0026rsquo;d buffer for custom processing[^2] 8. Utility Functions Function Name Purpose Parameters Return Type When to Use Detailed Explanation libbpf_get_error Extract error from pointer const void *ptr long When checking libbpf API errors Extracts error code from libbpf function pointers (deprecated in 1.0)[^12] libbpf_major_version Get major version void __u32 When checking libbpf version Returns major version number of libbpf library libbpf_minor_version Get minor version void __u32 When checking libbpf version Returns minor version number of libbpf library libbpf_version_string Get version string void const char * When displaying version info Returns human-readable version string libbpf_strerror Get error string int err, char *buf, size_t size int When formatting error messages Converts error code to human-readable string libbpf_set_print Set print callback libbpf_print_fn_t fn libbpf_print_fn_t When customizing debug output Sets custom function for libbpf debug/error messages[^2] libbpf_num_possible_cpus Get CPU count void int When sizing per-CPU data structures Returns number of possible CPUs for per-CPU map sizing[^2] libbpf_find_kernel_btf Find kernel BTF void struct btf * When accessing kernel type info Locates and loads kernel BTF for type information libbpf_find_vmlinux_btf_id Find kernel function BTF ID const char *name, enum bpf_attach_type attach_type int When working with kernel functions Finds BTF ID for kernel function by name libbpf_attach_type_by_name Get attach type by name const char *name, enum bpf_attach_type *attach_type int When parsing attach type strings Converts attach type name to enum value libbpf_prog_type_by_name Get program type by name const char *name, enum bpf_prog_type *prog_type, enum bpf_attach_type *expected_attach_type int When parsing program type strings Converts program type name to enum values libbpf_bpf_attach_type_str Get attach type string enum bpf_attach_type t const char * When displaying attach types Converts attach type enum to string representation[^2] libbpf_bpf_link_type_str Get link type string enum bpf_link_type t const char * When displaying link types Converts link type enum to string representation[^2] libbpf_bpf_map_type_str Get map type string enum bpf_map_type t const char * When displaying map types Converts map type enum to string representation[^2] libbpf_bpf_prog_type_str Get program type string enum bpf_prog_type t const char * When displaying program types Converts program type enum to string representation[^2] libbpf_probe_bpf_helper Probe helper availability enum bpf_prog_type prog_type, enum bpf_func_id helper_id, const void *opts int When checking feature support Tests if specific helper is available for program type[^2] libbpf_probe_bpf_map_type Probe map type support enum bpf_map_type map_type, const void *opts int When checking map support Tests if specific map type is supported by kernel[^2] libbpf_probe_bpf_prog_type Probe program type support enum bpf_prog_type prog_type, const void *opts int When checking program support Tests if specific program type is supported[^2] libbpf_set_memlock_rlim Set memory lock limit size_t memlock_bytes int When configuring memory limits Sets RLIMIT_MEMLOCK for BPF memory allocation libbpf_set_strict_mode Set strict mode enum libbpf_strict_mode mode int When enabling strict error handling Enables strict mode for cleaner error handling libbpf_register_prog_handler Register program handler const char *sec, enum bpf_prog_type prog_type, enum bpf_attach_type exp_attach_type, const struct libbpf_prog_handler_opts *opts int When extending libbpf Registers custom program section handler[^2] libbpf_unregister_prog_handler Unregister program handler int handler_id int When cleaning up handlers Removes previously registered program handler[^2] 9. BPF Linker Functions Function Name Purpose Parameters Return Type When to Use Detailed Explanation bpf_linker__new Create new linker const char *filename, struct bpf_linker_opts *opts struct bpf_linker * When linking multiple BPF objects Creates linker for combining multiple BPF object files bpf_linker__add_file Add file to linker struct bpf_linker *linker, const char *filename, const struct bpf_linker_file_opts *opts int When adding object files Adds BPF object file to linker for combination bpf_linker__finalize Finalize linking struct bpf_linker *linker int When completing link process Finalizes linking process and generates output bpf_linker__free Free linker struct bpf_linker *linker void When cleaning up linker Frees all linker resources 10. Low-Level BPF System Call Wrappers Function Name Purpose Parameters Return Type When to Use Detailed Explanation bpf_enable_stats Enable BPF statistics enum bpf_stats_type type int When enabling runtime statistics Enables BPF runtime statistics collection bpf_iter_create Create BPF iterator int link_fd int When creating custom iterators Creates iterator from BPF link for data traversal bpf_obj_get Get object from filesystem const char *pathname int When loading pinned objects Loads pinned BPF object from filesystem bpf_obj_get_info_by_fd Get object info by FD int bpf_fd, void *info, __u32 *info_len int When querying object metadata Generic object information retrieval bpf_obj_get_opts Get object with options const char *pathname, const struct bpf_obj_get_opts *opts int When loading with specific options Extended object loading with options bpf_obj_pin Pin object to filesystem int fd, const char *pathname int When persisting objects Pins BPF object to filesystem for persistence bpf_obj_pin_opts Pin object with options int fd, const char *pathname, const struct bpf_obj_pin_opts *opts int When pinning with options Extended pinning with additional options bpf_prog_attach Attach program int prog_fd, int attachable_fd, enum bpf_attach_type type, unsigned int flags int When attaching with raw FDs Low-level program attachment using file descriptors bpf_prog_attach_opts Attach program with options int prog_fd, int target, enum bpf_attach_type type, const struct bpf_prog_attach_opts *opts int When you need attach options Extended program attachment with additional options[^2] bpf_prog_bind_map Bind program to map int prog_fd, int map_fd, const struct bpf_prog_bind_opts *opts int When pre-binding programs to maps Associates program with map for optimization bpf_prog_detach Detach program int attachable_fd, enum bpf_attach_type type int When detaching by type Detaches program from attachment point by type bpf_prog_detach2 Detach specific program int prog_fd, int attachable_fd, enum bpf_attach_type type int When detaching specific program Detaches specific program by file descriptor bpf_prog_detach_opts Detach with options int prog_fd, int target, enum bpf_attach_type type, const struct bpf_prog_detach_opts *opts int When you need detach options Extended program detachment with options[^2] bpf_prog_get_fd_by_id Get program FD by ID __u32 id int When accessing program by ID Returns file descriptor for program with specified ID bpf_prog_get_fd_by_id_opts Get program FD with options __u32 id, const struct bpf_get_fd_by_id_opts *opts int When you need access options Extended FD retrieval with options bpf_prog_get_info_by_fd Get program info int prog_fd, struct bpf_prog_info *info, __u32 *info_len int When querying program metadata Retrieves detailed program information[^2] bpf_prog_get_next_id Get next program ID __u32 start_id, __u32 *next_id int When enumerating programs Iterates through all loaded programs bpf_prog_load Load program into kernel enum bpf_prog_type prog_type, const char *prog_name, const char *license, const struct bpf_insn *insns, size_t insn_cnt, struct bpf_prog_load_opts *opts int When loading with precise control Low-level program loading with full control over parameters[^2] bpf_prog_query Query attached programs int target_fd, enum bpf_attach_type type, __u32 query_flags, __u32 *attach_flags, __u32 *prog_ids, __u32 *prog_cnt int When listing attached programs Queries programs attached to specific target bpf_prog_query_opts Query with options int target, enum bpf_attach_type type, struct bpf_prog_query_opts *opts int When you need query options Extended program querying with options[^2] bpf_prog_test_run_opts Test program execution int prog_fd, struct bpf_test_run_opts *opts int When testing programs Runs program in test mode with provided input bpf_raw_tracepoint_open Open raw tracepoint const char *name, int prog_fd int When using raw tracepoints Opens raw tracepoint for minimal-overhead tracing bpf_raw_tracepoint_open_opts Open raw tracepoint with options int prog_fd, struct bpf_raw_tp_opts *opts int When you need raw tracepoint options Extended raw tracepoint opening bpf_task_fd_query Query task file descriptor int pid, int fd, __u32 flags, char *buf, __u32 *buf_len, __u32 *prog_id, __u32 *fd_type, __u64 *probe_offset, __u64 *probe_addr int When debugging attachments Queries information about BPF programs attached to task bpf_token_create Create BPF token int bpffs_fd, struct bpf_token_create_opts *opts int When delegating permissions Creates token for permission delegation to non-privileged processes[^2] 11. Traffic Control Functions Function Name Purpose Parameters Return Type When to Use Detailed Explanation bpf_tc_attach Attach TC program const struct bpf_tc_hook *hook, struct bpf_tc_opts *opts int When attaching to traffic control Attaches BPF program to traffic control hook for packet processing bpf_tc_detach Detach TC program const struct bpf_tc_hook *hook, const struct bpf_tc_opts *opts int When removing TC attachment Detaches BPF program from traffic control hook bpf_tc_hook_create Create TC hook struct bpf_tc_hook *hook int When setting up TC infrastructure Creates traffic control hook for program attachment bpf_tc_hook_destroy Destroy TC hook struct bpf_tc_hook *hook int When cleaning up TC hooks Destroys traffic control hook bpf_tc_query Query TC programs const struct bpf_tc_hook *hook, struct bpf_tc_opts *opts int When listing TC programs Queries programs attached to traffic control hook 12. XDP Functions Function Name Purpose Parameters Return Type When to Use Detailed Explanation bpf_xdp_attach Attach XDP program int ifindex, int prog_fd, __u32 flags, const struct bpf_xdp_attach_opts *opts int When attaching to network interface Attaches XDP program to network interface for early packet processing bpf_xdp_detach Detach XDP program int ifindex, __u32 flags, const struct bpf_xdp_attach_opts *opts int When removing XDP attachment Detaches XDP program from network interface bpf_xdp_query Query XDP programs int ifindex, int flags, struct bpf_xdp_query_opts *opts int When checking XDP status Queries XDP programs attached to interface bpf_xdp_query_id Query XDP program ID int ifindex, int flags, __u32 *prog_id int When getting attached program ID Returns ID of XDP program attached to interface ","permalink":"http://localhost:1313/blog/ebpf/a-comprehensive-guide-to-libbpf-functions/","summary":"1. BTF (BPF Type Format) Functions Function Name Purpose Parameters Return Type When to Use Detailed Explanation bpf_btf_get_fd_by_id Get BTF file descriptor by ID __u32 id int When you need to access BTF object with known ID Returns file descriptor for BTF object with given ID. Useful for introspection tools to examine type information of loaded programs[^1] bpf_btf_get_fd_by_id_opts Get BTF file descriptor by ID with options __u32 id, const struct bpf_get_fd_by_id_opts *opts int When you need BTF access with specific options Extended version with options like token_fd for permission delegation bpf_btf_get_info_by_fd Get BTF information by file descriptor int btf_fd, struct bpf_btf_info *info, __u32 *info_len int When you need metadata about BTF object Populates BTF object information structure with metadata like name, BTF data size, etc.","title":"The Complete eBPF Function Reference: A Comprehensive Guide to libbpf Functions"},{"content":"Description Developed few API\u0026rsquo;s regarding the monitoring of hardware application in GoLang. Collaborated with the Data team for creating visualizations for the collected data. Improved pipelines and implemented best practices for Containerization of the application. ","permalink":"http://localhost:1313/experience/new-leap-initiative/","summary":"Description Developed few API\u0026rsquo;s regarding the monitoring of hardware application in GoLang. Collaborated with the Data team for creating visualizations for the collected data. Improved pipelines and implemented best practices for Containerization of the application. ","title":"Software Engineer Trainee"},{"content":"Description ","permalink":"http://localhost:1313/experience/cloudraft/","summary":"Description ","title":"DevOps/SRE Intern"}]